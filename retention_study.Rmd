---
title: "Retention study proposal"
author: "Jason Whittle"
date: "8/24/2017"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## project info
started 8/24/2017

## Objective

Accurately model f-s and f-f retention at SLCC with a propensity score model that is cross-validated.

## Study plan

1. Pull 5 year of student data for students who: pulled 7 years 201040-201720
\begin{itemize}
\item a. did not complete 
\item b. transfer flag? no this is source of not retaining.
\item c. add a flag for f-s retention and f-f in R.
\item d. what data will be needed for a propensity score?
\end{itemize}

2. Split data up into a train and test group for cross-validation
\begin{itemize}
\item a. Use caret package in R
\item b. randomize the data. create folds in caret
\item c. decide on a 60/40 or 70/30 split
\end{itemize}

3. Use caret train to use "ranger"(random forest), "GLMNET", "GBM", "SVM"
\begin{itemize}
\item a. gbm package in R. Caret.train()
\item b. run model. caret.resamples() to find the best model
\item c. plot resamples() for 
\end{itemize}

4. Cross validate
\begin{itemize}
\item a. use GBM model on test set
\item b. Use 'cut' into groups : maybe clustering would help with this?
\item c. generate a ROC curve : caTools package colAUC(p class, actual, plotROC = T)
\item d. what is the AUC?
\item c. generate confusion matrix
\item d. evaluate if model tweaking is required in step 3.
\end{itemize}

5. cluster analysis of PS
\begin{itemize}
\item cluster for test or train or whole data set?
\item use PS for clustering analysis. What kind of predictive things can we see with this model?
\item look at promise students predicted PS scores
\end{itemize}

6. post score analysis
\begin{itemize}
\item look for clusters or cluster algo. 
\item characteristics of each cluster. zips, highschools, pell info, demos
\end{itemize}

# Uses for the retention model

\begin{itemize}
\item targeting students for retention programs.
\item evaluating retention programs. Are retention programs targeting students who are unlikely to retain? Evidence of self-selection
\item understand what factor predict retention
\end{itemize}

```{sql, eval = FALSE, echo=T}
-- SQL code to pull data from enroll

-- retention_flag
SELECT PIDM, S_YEAR, S_TERM, S_ENTRY_ACTION
FROM SLCC_STUDENTS
WHERE S_YEAR > 2009
AND S_EXTRACT = 'E';

-- term start date
SELECT STVTERM_CODE, STVTERM_START_DATE
FROM STVTERM
WHERE STVTERM_CODE 
IN (201040, 201120, 
201140, 201220, 
201240, 201320,
201340, 201420,
201440, 201520,
201540, 201620,
201640, 201720);

-- retention study
SELECT STUDENT_COURSE_ENROLLMENTS.PIDM, 
STUDENT_COURSE_ENROLLMENTS.CRN, 
STUDENT_COURSE_ENROLLMENTS.TERM_CODE, 
STUDENT_COURSE_ENROLLMENTS.FINAL_GRADE,
COURSE_LIST.INSTRUCTION_TYPE, 
COURSE_LIST.CAMPUS,
COURSE_LIST.TOTAL_ENROLLMENT, 
COURSE_LIST.CTE_CODE, 
COURSE_LIST.REMEDIAL_CODE, 
COURSE_LIST.TERM_CODE, 
COURSE_LIST.CRN, 
COURSE_LIST.TERM_CODE, 
COURSE_LIST.COURSE_SUBJECT, 
COURSE_LIST.COURSE_NUMB, 
COURSE_LIST.COURSE_BEGIN_TIME,
STUDENT_LIST.PIDM, 
STUDENT_LIST.COHORT_MIN_TERM, 
STUDENT_LIST.BIRTH_DATE, 
STUDENT_LIST.GENDER,
STUDENT_LIST.ETHNICITY, 
STUDENT_LIST.FIRST_GEN, 
STUDENT_LIST.LAST_TERM,
STUDENT_LIST.CURRENT_MAILING_ZIP,
STUDENT_LIST.HIGH_SCHOOL_CODE,
STUDENT_TERMS.PIDM, 
STUDENT_TERMS.ENROLL_TERM, 
STUDENT_TERMS.TERM_GPA,
STUDENT_TERMS.CUM_GPA_OVERALL, 
STUDENT_TERMS.CREDITS_WITHDRAWN, 
STUDENT_TERMS.CREDITS_ATT,
STUDENT_TERMS.FED_LOAN, 
STUDENT_TERMS.PELL_ELIG, 
STUDENT_TERMS.FAFSA, 
STUDENT_TERMS.PRIVATE_LOAN,
STUDENT_TERMS.CREDITS_FAILED,
STUDENT_TERMS.CUM_EARNED_OVERALL,
STUDENT_TERMS.PROMISE_PAID,
STUDENT_TERMS.PROMISE_OFFERED
FROM STUDENT_COURSE_ENROLLMENTS 
JOIN COURSE_LIST 
ON STUDENT_COURSE_ENROLLMENTS.CRN = COURSE_LIST.CRN 
AND STUDENT_COURSE_ENROLLMENTS.TERM_CODE = COURSE_LIST.TERM_CODE
JOIN STUDENT_LIST 
ON STUDENT_COURSE_ENROLLMENTS.PIDM = STUDENT_LIST.PIDM
JOIN STUDENT_TERMS
ON STUDENT_COURSE_ENROLLMENTS.PIDM = STUDENT_TERMS.PIDM
AND STUDENT_COURSE_ENROLLMENTS.TERM_CODE = STUDENT_TERMS.ENROLL_TERM
where STUDENT_COURSE_ENROLLMENTS.TERM_CODE not like '%50'
AND STUDENT_COURSE_ENROLLMENTS.TERM_CODE not like '%30'
AND STUDENT_COURSE_ENROLLMENTS.TERM_CODE IN  
(201040, 201120, 
201140, 201220, 
201240, 201320,
201340, 201420,
201440, 201520,
201540, 201620,
201640, 201720)
ORDER BY STUDENT_COURSE_ENROLLMENTS.TERM_CODE;
```

```{r, include=FALSE, echo=FALSE}
library(tidyverse); theme_set(theme_minimal())
library(lubridate)
library(caret)
library(ranger)
library(gbm)
```

```{r, echo=T, include=FALSE}
ret_data <- read_csv("retention_study.csv")
```

# Data cleaning and manipulation

\begin{itemize}
\item remove duplicate PIDM, ENROll_TERMS, and CRN, etc
\item calculate age at term
\item min and max course begin time
\item gender dummy
\item ethnicity dummies
\item number of remedial courses in term
\item first semester flag
\item term eng 1010 flag
\item term math 1010 flag
\item number of CTE coures/total courses per term
\end{itemize}

Data should end up at student/term level. Data is starting out at student/course/term level. 

```{r, echo=FALSE}
retention_flag_raw <- read_csv("retenion_flag_raw.csv") # yes, it is spelled wrong

# fixing the terms field
retention_flag_raw$TERM <- ifelse(retention_flag_raw$S_TERM == "2", 40, 
                                  ifelse(retention_flag_raw$S_TERM == "3", 20, 0))
retention_flag_raw$YEAR <- ifelse(retention_flag_raw$S_TERM == "3", 
                                  retention_flag_raw$S_YEAR, retention_flag_raw$S_YEAR - 1)

retention_flag_raw$ENROLL_TERM <- paste(retention_flag_raw$YEAR, retention_flag_raw$TERM, sep="")

ret_flag_data <- retention_flag_raw %>% 
  filter(TERM != 0) %>% 
  dplyr::select(PIDM, ENROLL_TERM, S_ENTRY_ACTION)

ret_flag_data$ENROLL_TERM <- as.integer(ret_flag_data$ENROLL_TERM)
rm(retention_flag_raw)
```

```{r, echo=FALSE}
ret_data <- ret_data[, !names(ret_data) %in% c("CRN_1", "TERM_CODE_1", "TERM_CODE_2", "PIDM_1", "PIDM_2", "ENROLL_TERM")]
ret_data <- ret_data %>% 
  left_join(ret_flag_data, by = c("PIDM" = "PIDM", "TERM_CODE" = "ENROLL_TERM"))
rm(ret_flag_data)
```

```{r, echo=FALSE}
stvterm <- read_csv("stvterm.csv")
ret_data <- ret_data %>% left_join(stvterm, by = c("TERM_CODE" = "STVTERM_CODE"))

ret_data$start_date <- dmy(ret_data$STVTERM_START_DATE)
ret_data$birth_date <- dmy(ret_data$BIRTH_DATE)
ret_data$term_age <- as.numeric((ret_data$start_date - ret_data$birth_date)/365)

# problem resolved. Problem was a YY default setting rather than YYYY in Oracle Developer.
# if you have a two-digit year
# century_adjustment_function <- function(x, year=1918){
#   m <- year(x) %% 100
#   year(x) <- ifelse(m > year %% 100, 1900+m, 2000+m)
#   x
# }
# 
# ret_data$birth_date <- century_adjustment_function(ret_data$birth_date)
rm(stvterm)
```

```{r, echo=FALSE}
# instrcution type simplification
ret_data$inst_type <- ifelse(ret_data$INSTRUCTION_TYPE == "Lecture/Lab" | 
                               ret_data$INSTRUCTION_TYPE == "Lecture", "L", 
                    ifelse(ret_data$INSTRUCTION_TYPE == "Online Lecture", "O",
                           ifelse(ret_data$INSTRUCTION_TYPE == "Hybrid (Online + Classroom)", "H", "OTH"))) # complicates things on a student/term level

ret_data$instrc_type_dum <- ifelse(ret_data$INSTRUCTION_TYPE == "Lecture/Lab" | 
                               ret_data$INSTRUCTION_TYPE == "Lecture", 1, 0)

# gender dummy
ret_data$male <- ifelse(ret_data$GENDER == "Male", 1, 0)

# Ethnicity needs to be a factored variable. not an ordered factor
ret_data$eth <- ifelse(ret_data$ETHNICITY == "Caucasian", "C", 
                       ifelse(ret_data$ETHNICITY == "Hispanic/Latino/Latina", "HLL", 
                              ifelse(ret_data$ETHNICITY == "Asian", "Asi", "oth_eth")))
# first gen/no/unknown
ret_data$first_gen <- ifelse(is.na(ret_data$FIRST_GEN) == TRUE, "NA",
                             ifelse(ret_data$FIRST_GEN == "No", "NO", "FG"))


# critical courses flags student/term
ret_data$ENGL1010 <- ifelse(ret_data$COURSE_SUBJECT == "ENGL" & 
                              ret_data$COURSE_NUMB == "1010", 1, 0)
ret_data$MATH1010 <- ifelse(ret_data$COURSE_SUBJECT == "MATH" &
                              ret_data$COURSE_NUMB == "1010", 1, 0)

# 5 digit zip
ret_data$zip <- substr(ret_data$CURRENT_MAILING_ZIP, 1, 5)

# first semester
ret_data$first_sem <- ifelse(ret_data$COHORT_MIN_TERM == ret_data$TERM_CODE, 1, 0)

# promise flags
ret_data$PROMISE_PAID[is.na(ret_data$PROMISE_PAID) == T] <- 0
ret_data$PROMISE_OFFERED[is.na(ret_data$PROMISE_OFFERED) == T] <- 0
ret_data$promise_p <- ifelse(ret_data$PROMISE_PAID > 0, 1, 0) # 727 total observations:  ret_data %>% group_by(PIDM) %>% filter(promise_p == 1) %>% distinct(PIDM) %>% View
ret_data$promise_o <- ifelse(ret_data$PROMISE_OFFERED > 0, 1, 0) # 1094 total observations: ret_data %>% group_by(PIDM) %>% filter(promise_o == 1) %>% distinct(PIDM) %>% View

# student/term level data to calculate. These will be joined to a student/terms data frame later
student_term_calc <- ret_data %>% group_by(PIDM, TERM_CODE) %>%
  dplyr::summarise(max_time = max(COURSE_BEGIN_TIME), 
            min_time = min(COURSE_BEGIN_TIME), 
            avg_cls_sz = mean(TOTAL_ENROLLMENT),
            crds_fails = sum(CREDITS_FAILED),
            crds_with = sum(CREDITS_WITHDRAWN),
            engl1010 = sum(ENGL1010),
            math1010 = sum(MATH1010),
            instrction_type = mean(instrc_type_dum)) # different amounts than student_term

# number of _____ student/term. to be joined to a student/term df later
cte_courses <- ret_data %>% filter(CTE_CODE == "V") %>% group_by(PIDM, TERM_CODE) %>% tally()
rem_courses <- ret_data %>% filter(REMEDIAL_CODE == "R") %>% group_by(PIDM, TERM_CODE) %>% tally()

# student level data to pull out. not necessary all avalible at student/term level
# ent_cohort <- ret_data %>% group_by(PIDM) %>% distinct(PIDM, COHORT_MIN_TERM, HIGH_SCHOOL_CODE, CURRENT_MAILING_ZIP)

# student/term level data to pull out
student_term <- ret_data %>% group_by(PIDM, TERM_CODE) %>% 
  distinct(FED_LOAN, CREDITS_ATT, FAFSA, 
           PROMISE_PAID, PROMISE_OFFERED, PRIVATE_LOAN, 
           CUM_GPA_OVERALL, CUM_EARNED_OVERALL, S_ENTRY_ACTION, 
           first_gen, TERM_GPA, promise_p, 
           promise_o, COHORT_MIN_TERM, HIGH_SCHOOL_CODE,
           male, eth,
           zip, first_sem, PELL_ELIG,
           LAST_TERM, term_age) # different amounts than student_term_calc

# joining into a student/term dataframe
test_join <- left_join(student_term, student_term_calc, by = c("PIDM" = "PIDM", "TERM_CODE" = "TERM_CODE"))
test_join <- test_join %>% left_join(cte_courses, by = c("PIDM" = "PIDM", "TERM_CODE" = "TERM_CODE"))
full_data <- test_join %>% left_join(rem_courses, by = c("PIDM" = "PIDM", "TERM_CODE" = "TERM_CODE"))
colnames(full_data)[33:34] <- c("cte_courses", "rem_courses")

# remove students who recived and award after 201030
# anti_join by PIDM and AWARD_TERM = TERM_CODE
awards <- read_csv("awards.csv")
awards <- cbind(awards, 1)
colnames(awards)[3] <- "award_flag"
# not perfect but it should work. several students have multiple awards.
full_data_awards <- full_data %>% left_join(awards, by = c("PIDM" = "PIDM", "TERM_CODE" = "AWARD_TERM"))
rm(awards, cte_courses, rem_courses, ret_flag_data, ret_sums,  ret_data, student_term, student_term_calc, test_join)
```

```{r, echo=FALSE, eval=FALSE}
# subseting the data for the PS promise model

# the eligible set of students to evaluated causality on: continuing students in 201640 who didn't graduate and had never recieved an award. 
# the 201640 variables to match on (not impacted by treatment):
elig_2016_set <- full_data_awards %>% 
  filter(TERM_CODE < 201700) %>% 
  filter(is.na(award_flag) == T) %>%
  filter(TERM_CODE == 201640) %>%
  filter(S_ENTRY_ACTION == "CS") %>%
  filter(PELL_ELIG == 1) %>%
  select(PIDM, TERM_CODE, term_age, first_gen, eth, male, 
         crds_fails, crds_with, COHORT_MIN_TERM, promise_p, 
         CUM_GPA_OVERALL, CUM_EARNED_OVERALL, FAFSA, PELL_ELIG) 

# variables prior to 201640 to match on
pre_201620 <- full_data_awards %>%
  filter(TERM_CODE == 201620) %>%
  filter(is.na(award_flag) == T) %>%
  select(PIDM, TERM_GPA, CREDITS_ATT, 
         FED_LOAN, PRIVATE_LOAN, first_sem, 
         instrction_type, cte_courses, rem_courses,
         engl1010, math1010, avg_cls_sz)

colnames(pre_201620) <- c("TERM_201620", "PIDM", "TERM_GPA_201620",  "CREDITS_ATT_201620", 
         "FED_LOAN_201620", "PRIVATE_LOAN_201620", "first_sem_201620", 
         "instrction_type_201620", "cte_courses_201620", "rem_courses_201620",
         "engl1010_201620", "math1010_201620", "avg_cls_sz_201620")

pre_201540 <- full_data_awards %>%
  filter(TERM_CODE == 201540) %>%
  filter(is.na(award_flag) == T) %>%
  select(PIDM, TERM_GPA, CREDITS_ATT, 
         FED_LOAN, PRIVATE_LOAN, first_sem, 
         instrction_type, cte_courses, rem_courses,
         engl1010, math1010, avg_cls_sz)

colnames(pre_201540) <- c("TERM_201540", "PIDM", "TERM_GPA_201540",  "CREDITS_ATT_201540", 
         "FED_LOAN_201540", "PRIVATE_LOAN_201540", "first_sem_201540", 
         "instrction_type_201540", "cte_courses_201540", "rem_courses_201540",
         "engl1010_201540", "math1010_201540", "avg_cls_sz_201540")
```

```{r, echo = FALSE, eval=FALSE}
# joining pre 201640 matching covariates
pre_201640 <- full_join(pre_201540, pre_201620,  by = "PIDM")

# joing 201640 and pre-201640 data together.
ps_data <- elig_2016_set %>% inner_join(pre_201640, by = "PIDM")

# ps_data %>% filter(is.na(TERM_201540) == T & is.na(TERM_GPA_201620)== T) %>% View() # =0!
# ps_data %>% filter(is.na(CUM_GPA_OVERALL) == T) %>% View() # students who haven't earned a grade
# removing them. CUM_GPA is a big thing to match on. None of the 107 are promise. 

ps_data <- ps_data %>% filter(is.na(CUM_GPA_OVERALL) == F)

```

```{r, echo=FALSE}
# maybe the NAs make this problem
# dealing with NAs in the data prior to matching
# appropriate to turn into 0
# ps_data$crds_fails
# ps_data$crds_with
# ps_data$CREDITS_ATT_201540
# ps_data$FED_LOAN_201540
# ps_data$PRIVATE_LOAN_201540
# ps_data$first_sem_201540
# 
# # columns to be removed/ignored
# ps_data$TERM_201540
# ps_data$TERM_201620
# 
# # how to handle NAs for
# ps_data$instrction_type_201540
```

```{r, echo=FALSE, eval=FALSE}
# two seperate matches
# 201620 
ps_data_201620 <- elig_2016_set %>% inner_join(pre_201620, by = "PIDM") %>% filter(is.na(CUM_GPA_OVERALL) == FALSE)
# dim(ps_data_201620) # 9671 by 26
# NAs
ps_data_201620$crds_fails[is.na(ps_data_201620$crds_fails) == T] <- 0
ps_data_201620$crds_with[is.na(ps_data_201620$crds_with) == T] <- 0
ps_data_201620$cte_courses_201620[is.na(ps_data_201620$cte_courses_201620) == T] <- 0
ps_data_201620$rem_courses_201620[is.na(ps_data_201620$rem_courses_201620) == T] <- 0
ps_data_201620$PELL_ELIG <- as.double(ps_data_201620$PELL_ELIG)
ps_data_201620$PELL_ELIG[is.na(ps_data_201620$PELL_ELIG) == T] <- 0
ps_data_201620$eth <- as.factor(ps_data_201620$eth)
ps_data_201620$eth[is.na(ps_data_201620$eth) == T] <- "oth_eth"
ps_data_201620$first_gen <- as.factor(ps_data_201620$first_gen)

# 201540
ps_data_201540 <- elig_2016_set %>% inner_join(pre_201540, by = "PIDM") %>% filter(is.na(CUM_GPA_OVERALL) == FALSE)
# dim(ps_data_201540) # 8548 by 26
#NAs
ps_data_201540$crds_fails[is.na(ps_data_201540$crds_fails) == T] <- 0
ps_data_201540$crds_with[is.na(ps_data_201540$crds_with) == T] <- 0
ps_data_201540$cte_courses_201540[is.na(ps_data_201540$cte_courses_201540) == T] <- 0
ps_data_201540$rem_courses_201540[is.na(ps_data_201540$rem_courses_201540) == T] <- 0
ps_data_201540$PELL_ELIG <- as.double(ps_data_201540$PELL_ELIG)
ps_data_201540$PELL_ELIG[is.na(ps_data_201540$PELL_ELIG) == T] <- 0
ps_data_201540$eth <- as.factor(ps_data_201540$eth)
ps_data_201540$eth[is.na(ps_data_201540$eth) == T] <- "oth_eth"
ps_data_201540$first_gen <- as.factor(ps_data_201540$first_gen)

# both 201540 & 201620

int_join <- pre_201540 %>% inner_join(pre_201620, by = "PIDM")
ps_1516 <- elig_2016_set %>% inner_join(int_join, by = "PIDM") %>% filter(is.na(CUM_GPA_OVERALL) == FALSE)
rm(int_join)
# dim(ps_1516) # 7118 by 38

ps_1516$crds_fails[is.na(ps_1516$crds_fails) == T] <- 0
ps_1516$crds_with[is.na(ps_1516$crds_with) == T] <- 0
ps_1516$cte_courses_201540[is.na(ps_1516$cte_courses_201540) == T] <- 0
ps_1516$rem_courses_201540[is.na(ps_1516$rem_courses_201540) == T] <- 0
ps_1516$cte_courses_201620[is.na(ps_1516$cte_courses_201620) == T] <- 0
ps_1516$rem_courses_201620[is.na(ps_1516$rem_courses_201620) == T] <- 0
ps_1516$PELL_ELIG <- as.double(ps_1516$PELL_ELIG)
ps_1516$PELL_ELIG[is.na(ps_1516$PELL_ELIG) == T] <- 0
ps_1516$eth <- as.factor(ps_1516$eth)
ps_1516$eth[is.na(ps_1516$eth) == T] <- "oth_eth"
ps_1516$first_gen <- as.factor(ps_1516$first_gen)
```

# modeling promise inclusion first.

As per Webb. Model retention first based on 

```{r, echo=FALSE, eval=FALSE}
library(caret)
# using ps_1516 (both 1540 & 1620) 
# 160 promise students in the data set
ps_1516 <- ps_1516[, !names(ps_1516) %in% c("TERM_201540", "TERM_201620", "TERM_CODE", "first_sem_201620")] # there was no variation in first_sem_201620

# library(twang)
# ps_model_twang <- ps(promise_p ~ ., data = ps_1516)

# Generalized boosted regression models
library(gbm)
ps_model_gbm <- gbm(promise_p ~ . - PIDM, 
                    data = ps_1516, 
                    n.trees = 10000)
n <- gbm.perf(ps_model_gbm) # 5639
plot(ps_model_gbm, i.var = 1)
pretty.gbm.tree(ps_model_gbm)
print(ps_model_gbm)

ps_gbm <- predict(ps_model_gbm, 
                  n.trees = 5639, 
                  ps_1516, 
                  type = "response")

ps_gbm
summary(ps_gbm)

blah <- cbind(ps_gbm)

ps_1516_gbm <- data.frame(ps_1516, blah)
rm(blah)

# Random forest
library(ranger)
ps_model_ranger <- ranger(as.factor(promise_p) ~ . -PIDM, 
                          num.trees = 500, 
                          data = ps_1516, 
                          write.forest = TRUE, 
                          probability = TRUE)

print(ps_model_ranger)

ps_ranger <- predict(ps_model_ranger, ps_1516, 
                     type = "response", 
                     num.trees = 250) # way! over fitted. Perfectly predicts essentially 

blah <- cbind(ps_ranger$predictions)
ps_1516_ranger <- data.frame(ps_1516, blah[,2])
rm(blah)

# logistic regression: scale all variables first? interact variables?
ps_model_glm <- glm(promise_p ~ . - PIDM, 
                    data = ps_1516, 
                    family = "binomial")
summary(ps_model_glm)

X <- 
ps_glm <- predict(ps_model_glm, ps_1516, type = "response")

blah <- cbind(ps_glm)
ps_1516_glm <- data.frame(ps_1516, blah)
rm(blah)

# gbm
set.seed(42)
model_gbm <- train(as.factor(promise_p) ~ . -PIDM, 
               data = ps_1516, 
               method = "gbm", 
               trControl = trainControl(method = "cv", 
                                        number = 10, 
                                        verboseIter = TRUE))

ps_caret <- predict(model_gbm, ps_1516, type = "prob")
ps_gbm <- cbind(ps_caret$`1`)
ps_caret_gbm <- data.frame(ps_1516, ps_gbm)
rm(ps_gbm)

# logit
sed.seed(42)
model_glm <- train(as.factor(promise_p) ~ . -PIDM, 
               data = ps_1516, 
               method = "glm", 
               trControl = trainControl(method = "cv", 
                                        number = 10, 
                                        verboseIter = TRUE))

ps_c

# ranger
set.seed(42)
model_ranger <- train(as.factor(promise_p) ~ . -PIDM, 
               data = ps_1516, 
               method = "ranger", 
               trControl = trainControl(method = "cv", 
                                        number = 10, 
                                        verboseIter = TRUE))

ps_caret <- predict(model_ranger, ps_1516, type = "prob")
ps_ranger <- cbind(ps_caret$`1`)
ps_caret_ranger <- data.frame(ps_1516, ps_ranger)
rm(ps_ranger)
```

```{r, echo=FALSE, eval=FALSE}
# more plots
ps_1516_gbm %>%
  ggplot() + 
  geom_histogram(aes(ps_gbm)) +
  facet_wrap(~as.factor(promise_p), scales = "free")
  
ps_1516_ranger %>%
  ggplot() + 
  geom_histogram(aes(blah...2.)) +
  facet_wrap(~as.factor(promise_p), scales = "free")

ps_1516_glm %>%
  ggplot() + 
  geom_histogram(aes(ps_glm)) +
  facet_wrap(~as.factor(promise_p), scales = "free")

# caret plots
ps_caret_gbm %>%
  ggplot() + 
  geom_histogram(aes(ps_gbm)) + 
  facet_wrap(~as.factor(promise_p), scales = "free")

ps_caret_gbm %>%
  ggplot() + 
  geom_density(aes(ps_gbm, col = as.factor(promise_p))) +
  xlab("propensity scores from gbm") + 
  ylab("") 
```

# Jessie's idea


Generate propensity scores for all exact match on minimum cohort year.

```{r, echo=FALSE}
# select students enrolled in 201640 who did not graduate in 201640
full_data_awards$PIDM <- as.character(full_data_awards$PIDM)
pidm_201640 <- full_data_awards %>% 
  filter(TERM_CODE == 201640) %>% 
  filter(is.na(award_flag) == T) %>% 
  filter(PELL_ELIG == 1) %>% 
  dplyr::select(PIDM, TERM_CODE) # 5975... 5974 unique

elig_2016_set <- full_data_awards %>% 
  dplyr::semi_join(pidm_201640, by = "PIDM") # student/term 

fixed_2016 <- elig_2016_set %>% filter(TERM_CODE == 201640) %>% select(PIDM, TERM_CODE, term_age, first_gen, eth, male, 
         crds_fails, crds_with, COHORT_MIN_TERM, promise_p, CUM_GPA_OVERALL, CUM_EARNED_OVERALL)

# elig_2016_set %>% group_by(COHORT_MIN_TERM) %>% tally() %>% View
# elig_2016_set %>% group_by(COHORT_MIN_TERM) %>% filter(promise_p == 1) %>% tally() %>% View

# both 2015 to 2016

# just 2016

# just 2015

# all other cs

# all first semester

fixed_cov <- full_data_awards %>% 
  filter(TERM_CODE == 201640) %>%
  dplyr::select( eth, male, COHORT_MIN_TERM,
                zip, HIGH_SCHOOL_CODE, promise_p,
                first_gen, CUM_GPA_OVERALL, CUM_EARNED_OVERALL)

ps_set <- 
```

```{r, echo=FALSE}
library(caret)
model_gbm <- train(as.factor(promise_p) ~ . -PIDM, 
                  data = ps_set, 
               method = "gbm", 
               trControl = trainControl(method = "cv", 
                                        number = 10, 
                                        verboseIter = TRUE))

```



```{r, echo=FALSE}
# matching
library(Matching)

```

