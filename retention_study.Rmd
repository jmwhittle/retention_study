---
title: "Retention study proposal"
author: "Jason Whittle"
date: "8/24/2017"
output: pdf_document
---

```{r setup, include=FALSE, cache=TRUE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```
# project info
started 8/24/2017
analysis finished 9/29/2017 - with a two weeks out of the office during this time. 
additional write up to promise report 10/2/2017

## Objective

Accurately model f-s and f-f retention at SLCC with a propensity score model that is cross-validated.

## Study plan

1. Pull 5 year of student data for students who: pulled 7 years 201040-201720
\begin{itemize}
\item a. did not complete 
\item b. transfer flag? no this is source of not retaining.
\item c. add a flag for f-s retention and f-f in R.
\item d. what data will be needed for a propensity score?
\end{itemize}

2. Split data up into a train and test group for cross-validation
\begin{itemize}
\item a. Use caret package in R
\item b. randomize the data. create folds in caret
\item c. decide on a 60/40 or 70/30 split
\end{itemize}

3. Use caret train to use "ranger"(random forest), "GLMNET", "GBM", "SVM"
\begin{itemize}
\item a. gbm package in R. Caret.train()
\item b. run model. caret.resamples() to find the best model
\item c. plot resamples() for 
\end{itemize}

4. Cross validate
\begin{itemize}
\item a. use GBM model on test set
\item b. Use 'cut' into groups : maybe clustering would help with this?
\item c. generate a ROC curve : caTools package colAUC(p class, actual, plotROC = T)
\item d. what is the AUC?
\item c. generate confusion matrix
\item d. evaluate if model tweaking is required in step 3.
\end{itemize}

5. cluster analysis of PS
\begin{itemize}
\item cluster for test or train or whole data set?
\item use PS for clustering analysis. What kind of predictive things can we see with this model?
\item look at promise students predicted PS scores
\end{itemize}

6. post score analysis
\begin{itemize}
\item look for clusters or cluster algo. 
\item characteristics of each cluster. zips, highschools, pell info, demos
\end{itemize}

## Uses for the retention model

\begin{itemize}
\item targeting students for retention programs.
\item evaluating retention programs. Are retention programs targeting students who are unlikely to retain? Evidence of self-selection
\item understand what factor predict retention
\end{itemize}

## SQL used to pull data from enroll tables.
- Oracle's SQL Developer 2 was used. not Pepe the Alt-right Toad.
```{sql, eval = FALSE, echo=T}
-- SQL code to pull data from enroll

-- retention_flag
SELECT PIDM, S_YEAR, S_TERM, S_ENTRY_ACTION
FROM SLCC_STUDENTS
WHERE S_YEAR > 2009
AND S_EXTRACT = 'E';

-- term start date
SELECT STVTERM_CODE, STVTERM_START_DATE
FROM STVTERM
WHERE STVTERM_CODE 
IN (201040, 201120, 
201140, 201220, 
201240, 201320,
201340, 201420,
201440, 201520,
201540, 201620,
201640, 201720,
201740);

-- add former concurrent enrollment
-- credits failed seems fishy PIDM 411155

-- retention study
SELECT STUDENT_COURSE_ENROLLMENTS.PIDM, 
STUDENT_COURSE_ENROLLMENTS.CRN, 
STUDENT_COURSE_ENROLLMENTS.TERM_CODE, 
STUDENT_COURSE_ENROLLMENTS.FINAL_GRADE,
COURSE_LIST.INSTRUCTION_TYPE, 
COURSE_LIST.CAMPUS,
COURSE_LIST.TOTAL_ENROLLMENT, 
COURSE_LIST.CTE_CODE, 
COURSE_LIST.REMEDIAL_CODE, 
COURSE_LIST.TERM_CODE, 
COURSE_LIST.CRN, 
COURSE_LIST.TERM_CODE, 
COURSE_LIST.COURSE_SUBJECT, 
COURSE_LIST.COURSE_NUMB, 
COURSE_LIST.COURSE_BEGIN_TIME,
STUDENT_LIST.PIDM, 
STUDENT_LIST.COHORT_MIN_TERM, 
STUDENT_LIST.BIRTH_DATE, 
STUDENT_LIST.GENDER,
STUDENT_LIST.ETHNICITY, 
STUDENT_LIST.FIRST_GEN, 
STUDENT_LIST.LAST_TERM,
STUDENT_LIST.CURRENT_MAILING_ZIP,
STUDENT_LIST.HIGH_SCHOOL_CODE,
STUDENT_TERMS.PIDM, 
STUDENT_TERMS.ENROLL_TERM, 
STUDENT_TERMS.CUM_GPA_OVERALL, 
STUDENT_TERMS.CREDITS_WITHDRAWN, 
STUDENT_TERMS.CREDITS_ATT,
STUDENT_TERMS.FED_LOAN, 
STUDENT_TERMS.PELL_ELIG, 
STUDENT_TERMS.FAFSA, 
STUDENT_TERMS.PRIVATE_LOAN,
STUDENT_TERMS.CREDITS_FAILED,
STUDENT_TERMS.CUM_EARNED_OVERALL,
STUDENT_TERMS.PROMISE_PAID,
STUDENT_TERMS.PROMISE_OFFERED
FROM STUDENT_COURSE_ENROLLMENTS 
JOIN COURSE_LIST 
ON STUDENT_COURSE_ENROLLMENTS.CRN = COURSE_LIST.CRN 
AND STUDENT_COURSE_ENROLLMENTS.TERM_CODE = COURSE_LIST.TERM_CODE
JOIN STUDENT_LIST 
ON STUDENT_COURSE_ENROLLMENTS.PIDM = STUDENT_LIST.PIDM
JOIN STUDENT_TERMS
ON STUDENT_COURSE_ENROLLMENTS.PIDM = STUDENT_TERMS.PIDM
AND STUDENT_COURSE_ENROLLMENTS.TERM_CODE = STUDENT_TERMS.ENROLL_TERM
where STUDENT_COURSE_ENROLLMENTS.TERM_CODE not like '%50'
AND STUDENT_COURSE_ENROLLMENTS.TERM_CODE not like '%30'
AND STUDENT_COURSE_ENROLLMENTS.TERM_CODE IN  
(201040, 201120, 
201140, 201220, 
201240, 201320,
201340, 201420,
201440, 201520,
201540, 201620,
201640, 201720,
201740)
ORDER BY STUDENT_COURSE_ENROLLMENTS.TERM_CODE;
```

## loading basic data manipulation package libraries
```{r, include=FALSE, echo=T, message=F}
library(lubridate)
library(tidyverse); theme_set(theme_minimal())
```

## importing base data from sql pull above. 
- student/term/course level
- aggregation and transformation will be done in R. 
```{r, echo=T, include=T, message=F}
ret_data <- read_csv("retention_study.csv")
```

# Data cleaning and manipulation

\begin{itemize}
\item remove duplicate PIDM, ENROll TERMS, and CRN, etc
\item calculate age at term
\item min and max course begin time
\item gender dummy
\item ethnicity dummies
\item number of remedial courses in term
\item first semester flag
\item term eng 1010 flag
\item term math 1010 flag
\item number of CTE coures/total courses per term
\end{itemize}

Data should end up at student/term level. Data is starting out at student/course/term level. 

## importing raw term entry action data.
```{r, echo=T, message=F}
retention_flag_raw <- read_csv("retenion_flag_raw.csv") # yes, it is spelled wrong

# fixing the terms field
retention_flag_raw$TERM <- ifelse(retention_flag_raw$S_TERM == "2", 40, 
                                  ifelse(retention_flag_raw$S_TERM == "3", 20, 0))
retention_flag_raw$YEAR <- ifelse(retention_flag_raw$S_TERM == "3", 
                                  retention_flag_raw$S_YEAR, retention_flag_raw$S_YEAR - 1)

retention_flag_raw$ENROLL_TERM <- paste(retention_flag_raw$YEAR, retention_flag_raw$TERM, sep="")

ret_flag_data <- retention_flag_raw %>% 
  filter(TERM != 0) %>% 
  dplyr::select(PIDM, ENROLL_TERM, S_ENTRY_ACTION)

ret_flag_data$ENROLL_TERM <- as.integer(ret_flag_data$ENROLL_TERM)
rm(retention_flag_raw)
```

## joining retention/term entry action data to ret_data.
```{r, echo=T, message=F}
ret_data <- ret_data[, !names(ret_data) %in% c("CRN_1", "TERM_CODE_1", "TERM_CODE_2", "PIDM_1", "PIDM_2", "ENROLL_TERM")]
ret_data <- ret_data %>% 
  left_join(ret_flag_data, by = c("PIDM" = "PIDM", "TERM_CODE" = "ENROLL_TERM"))
rm(ret_flag_data)
```

## importing term start date data
```{r, echo=T, message=F}
stvterm <- read_csv("stvterm.csv")
ret_data <- ret_data %>% left_join(stvterm, by = c("TERM_CODE" = "STVTERM_CODE"))

ret_data$start_date <- dmy(ret_data$STVTERM_START_DATE)
ret_data$birth_date <- dmy(ret_data$BIRTH_DATE)
ret_data$term_age <- as.numeric((ret_data$start_date - ret_data$birth_date)/365)

rm(stvterm)
```

## creating/transforming variables into aggregates
```{r, echo=T, message=F}
# instrcution type simplification
ret_data$inst_type <- ifelse(ret_data$INSTRUCTION_TYPE == "Lecture/Lab" | 
                               ret_data$INSTRUCTION_TYPE == "Lecture", "L", 
                    ifelse(ret_data$INSTRUCTION_TYPE == "Online Lecture", "O",
                           ifelse(ret_data$INSTRUCTION_TYPE == "Hybrid (Online + Classroom)", "H", "OTH"))) # complicates things on a student/term level

ret_data$instrc_type_dum <- ifelse(ret_data$INSTRUCTION_TYPE == "Lecture/Lab" | 
                               ret_data$INSTRUCTION_TYPE == "Lecture", 1, 0)

# adding full career instrcution type value
inst <- ret_data %>% 
  dplyr::filter(TERM_CODE != 201720 | TERM_CODE != 201730 | TERM_CODE != 201640) %>%
  dplyr::group_by(PIDM) %>%
  dplyr::summarise(inst = mean(instrc_type_dum)) 

ret_data <- ret_data %>% left_join(inst, by = "PIDM")

# gender dummy
ret_data$male <- ifelse(ret_data$GENDER == "Male", 1, 0)

# Ethnicity needs to be a factored variable. not an ordered factor
ret_data$eth <- ifelse(ret_data$ETHNICITY == "Caucasian", "C", 
                       ifelse(ret_data$ETHNICITY == "Hispanic/Latino/Latina", "HLL", 
                              ifelse(ret_data$ETHNICITY == "Asian", "Asi", "oth_eth")))
# first gen/no/unknown
ret_data$first_gen <- ifelse(is.na(ret_data$FIRST_GEN) == TRUE, "NA",
                             ifelse(ret_data$FIRST_GEN == "No", "NO", "FG"))


# critical courses flags student/term
ret_data$ENGL1010 <- ifelse(ret_data$COURSE_SUBJECT == "ENGL" & 
                              ret_data$COURSE_NUMB == "1010", 1, 0)
ret_data$MATH1010 <- ifelse(ret_data$COURSE_SUBJECT == "MATH" &
                              ret_data$COURSE_NUMB == "1010", 1, 0)

# highest math and engl class
ret_data$COURSE_NUMB <- as.numeric(ret_data$COURSE_NUMB)
engl <- ret_data %>% 
  dplyr::group_by(PIDM) %>% 
  dplyr::filter(COURSE_SUBJECT == "ENGL") %>% 
  dplyr::filter(TERM_CODE != 201720 | TERM_CODE != 201730 | TERM_CODE != 201640) %>%
  dplyr::summarise(engl = max(COURSE_NUMB)) %>% 
  ungroup() 

ret_data <- ret_data %>% left_join(engl, by = "PIDM")
ret_data$engl <- as.character(ret_data$engl)
ret_data$engl[is.na(ret_data$engl) == TRUE] <- "NA"

math <- ret_data %>%
  dplyr::group_by(PIDM) %>%
  filter(COURSE_SUBJECT == "MATH") %>%
  filter(TERM_CODE != 201720 | TERM_CODE != 201730 | TERM_CODE != 201640) %>%
  dplyr::summarise(math = max(COURSE_NUMB)) %>%
  ungroup()

ret_data <- ret_data %>% left_join(math, by = "PIDM")
ret_data$math <- as.character(ret_data$math)
ret_data$math[is.na(ret_data$math) == TRUE] <- "NA"

# 5 digit zip
ret_data$zip <- substr(ret_data$CURRENT_MAILING_ZIP, 1, 5)

# first semester
ret_data$first_sem <- ifelse(ret_data$COHORT_MIN_TERM == ret_data$TERM_CODE, 1, 0)

# promise flags
ret_data$PROMISE_PAID[is.na(ret_data$PROMISE_PAID) == T] <- 0
ret_data$PROMISE_OFFERED[is.na(ret_data$PROMISE_OFFERED) == T] <- 0
ret_data$promise_p <- ifelse(ret_data$PROMISE_PAID > 0, 1, 0) # 727 total observations:  ret_data %>% group_by(PIDM) %>% filter(promise_p == 1) %>% distinct(PIDM) %>% View
ret_data$promise_o <- ifelse(ret_data$PROMISE_OFFERED > 0, 1, 0) # 1094 total observations: ret_data %>% group_by(PIDM) %>% filter(promise_o == 1) %>% distinct(PIDM) %>% View

# retnetion flag 201740 & 201720
# doesn't work
ret_data$ret1720 <- ifelse(ret_data$TERM_CODE == 201720, 1, 0)
ret_data$ret1740 <- ifelse(ret_data$TERM_CODE == 201740, 1, 0)

ret1720 <- ret_data %>% group_by(PIDM) %>% dplyr::summarise(ret1720 = max(ret1720))
ret1740 <- ret_data %>% group_by(PIDM) %>% dplyr::summarise(ret1740 = max(ret1740))


# career fed/private loan
fed <- ret_data %>%
  group_by(PIDM) %>%
  filter(TERM_CODE != 201720 | TERM_CODE != 201730 | TERM_CODE != 201640) %>%
  dplyr::summarise(fed_career = sum(FED_LOAN)) %>%
  ungroup

ret_data <- ret_data %>% left_join(fed, by = "PIDM")

pri <- ret_data %>%
  group_by(PIDM) %>%
  filter(TERM_CODE != 201720 | TERM_CODE != 201730 | TERM_CODE != 201640) %>%
  dplyr::summarise(pri_career = sum(PRIVATE_LOAN)) %>%
  ungroup

ret_data <- ret_data %>% left_join(pri, by = "PIDM")

# career fails/withdrawn

fails <- ret_data %>%
  group_by(PIDM, TERM_CODE) %>%
  dplyr::summarise(fails_term = max(CREDITS_FAILED))

fails_career <- fails %>%
  group_by(PIDM) %>%
  filter(TERM_CODE != 201720 | TERM_CODE != 201730 | TERM_CODE != 201640) %>%
  dplyr::summarise(fails_career = sum(fails_term))

ret_data <- ret_data %>% left_join(fails_career, by = "PIDM")
ret_data$fails_career[is.na(ret_data$fails_career) == T] <- 0

withs <- ret_data %>%
  group_by(PIDM, TERM_CODE) %>%
  dplyr::summarise(with_term = max(CREDITS_WITHDRAWN))

withs_career <- withs %>%
  group_by(PIDM) %>%
  filter(TERM_CODE != 201720 | TERM_CODE != 201730 | TERM_CODE != 201640) %>%
  dplyr::summarise(withs_career = sum(with_term))

ret_data <- ret_data %>% left_join(withs_career, by = "PIDM")
ret_data$withs_career[is.na(ret_data$withs_career) == T] <- 0

# mean credits attempted per term
mean_crd_att <- ret_data %>%
  group_by(PIDM) %>%
  filter(TERM_CODE != 201720 | TERM_CODE != 201730 | TERM_CODE != 201640) %>%
  dplyr::summarise(mean_crd_att = mean(CREDITS_ATT))

ret_data <- ret_data %>% left_join(mean_crd_att, by = "PIDM")

```
- This section looks good. ret1740 hasn't been added to banner yet but when it is, re-run the SQL and then they data will be ready for matching. 

## joining variables to data
```{r, echo=T, message=F}
# student/term level data to calculate. These will be joined to a student/terms data frame later
student_term_calc <- ret_data %>% group_by(PIDM, TERM_CODE) %>%
  dplyr::summarise(max_time = max(COURSE_BEGIN_TIME), 
            min_time = min(COURSE_BEGIN_TIME), 
            avg_cls_sz = mean(TOTAL_ENROLLMENT),
            crds_fails = max(CREDITS_FAILED),
            crds_with = max(CREDITS_WITHDRAWN)) # different amounts than student_term

# # number of _____ student/term. to be joined to a student/term df later # switching to career sum for matching 
# but check the term for validating matches. 
cte_courses <- ret_data %>% filter(CTE_CODE == "V") %>% group_by(PIDM, TERM_CODE) %>% tally()
rem_courses <- ret_data %>% filter(REMEDIAL_CODE == "R") %>% group_by(PIDM, TERM_CODE) %>% tally()

cte_career <- ret_data %>% 
  filter(CTE_CODE == "V") %>% 
  filter(TERM_CODE != 201720 | TERM_CODE != 201730 | TERM_CODE != 201640) %>% 
  group_by(PIDM) %>% 
  tally()

rem_career <- ret_data %>% filter(REMEDIAL_CODE == "R") %>% 
  filter(TERM_CODE != 201720 | TERM_CODE != 201730 | TERM_CODE != 201640) %>%
  group_by(PIDM) %>% 
  tally()

term_gpa_201640 <- ret_data %>% filter(TERM_CODE == 201640) %>%
  group_by(PIDM) %>%
  dplyr::summarise(term_gpa_201640 = max(TERM_GPA))

# student level data to pull out. not necessary all avalible at student/term level
# ent_cohort <- ret_data %>% group_by(PIDM) %>% distinct(PIDM, COHORT_MIN_TERM, HIGH_SCHOOL_CODE, CURRENT_MAILING_ZIP)

# student/term level data to pull out
student_term <- ret_data %>% group_by(PIDM, TERM_CODE) %>% 
  distinct(FED_LOAN, CREDITS_ATT, FAFSA, 
           PROMISE_PAID, PROMISE_OFFERED, PRIVATE_LOAN, 
           CUM_GPA_OVERALL, CUM_EARNED_OVERALL, S_ENTRY_ACTION, 
           first_gen, TERM_GPA, promise_p, 
           promise_o, COHORT_MIN_TERM, HIGH_SCHOOL_CODE,
           male, eth, fed_career, pri_career,
           zip, first_sem, PELL_ELIG,
           LAST_TERM, term_age, engl, math, inst, fails_career, withs_career, mean_crd_att)

# joining into a student/term dataframe
test_join <- left_join(student_term, student_term_calc, by = c("PIDM" = "PIDM", "TERM_CODE" = "TERM_CODE"))
test_join <- test_join %>% left_join(cte_courses, by = c("PIDM" = "PIDM", "TERM_CODE" = "TERM_CODE"))
full_data <- test_join %>% left_join(rem_courses, by = c("PIDM" = "PIDM", "TERM_CODE" = "TERM_CODE"))
colnames(full_data)[38:39] <- c("cte_courses", "rem_courses")
full_data <- full_data %>% left_join(cte_career, by = "PIDM")
full_data <- full_data %>% left_join(rem_career, by = "PIDM")
colnames(full_data)[40:41] <- c("cte_career", "rem_career")
full_data <- full_data %>% left_join(term_gpa_201640, by = "PIDM")

# fixing NAs
full_data$cte_courses[is.na(full_data$cte_courses) == T] <- 0
full_data$rem_courses[is.na(full_data$rem_courses) == T] <- 0
full_data$cte_career[is.na(full_data$cte_career) == T] <- 0
full_data$rem_career[is.na(full_data$rem_career) == T] <- 0
full_data$crds_fails[is.na(full_data$crds_fails) == T] <- 0
full_data$crds_with[is.na(full_data$crds_with) == T] <- 0

# remove students who recived and award after 201030
# anti_join by PIDM and AWARD_TERM = TERM_CODE
awards <- read_csv("awards.csv")
awards <- cbind(awards, 1)
colnames(awards)[3] <- "award_flag"
# not perfect but it should work. several students have multiple awards.
full_data_awards <- full_data %>% left_join(awards, by = c("PIDM" = "PIDM", "TERM_CODE" = "AWARD_TERM"))
full_data_awards <- full_data_awards %>% left_join(ret1720, by = "PIDM")
full_data_awards <- full_data_awards %>% left_join(ret1740, by = "PIDM")
rm(awards, cte_courses, rem_courses, cte_career, rem_career, 
   ret_data, student_term, student_term_calc, test_join, engl, math,
   fed, inst, pri, withs, withs_career, fails, fails_career, ret1720, ret1740)
```
- Joins checkout, column naming was correct. 

## creating sub matching groups
```{r, echo=T, message=F}

# grouping by students with and without a cum_gpa_overall. Most of the 440 ff w/gpa are probably former concurrent
cs_gpa_2016 <-  full_data_awards %>%
  filter(is.na(award_flag) == T) %>%
  filter(TERM_CODE == 201640) %>%
  filter(is.na(CUM_GPA_OVERALL) == F & first_sem == 0) %>%
  filter(PELL_ELIG == 1) %>%
  dplyr::select(PIDM, TERM_CODE, term_age, first_gen, eth, male, 
         COHORT_MIN_TERM, promise_p, 
         CUM_GPA_OVERALL, CUM_EARNED_OVERALL, PELL_ELIG,
         math, engl, inst, fed_career, pri_career, cte_career, 
         rem_career, fails_career, withs_career, ret1720, ret1740,
         avg_cls_sz, zip, mean_crd_att, first_sem, term_gpa_201640) 

ff_nogpa_2016 <- full_data_awards %>%
  filter(is.na(award_flag) == T) %>%
  filter(TERM_CODE == 201640) %>%
  filter(is.na(CUM_GPA_OVERALL) == T & first_sem == 1) %>%
  filter(PELL_ELIG == 1) %>%
  dplyr::select(PIDM, TERM_CODE, term_age, first_gen, eth, male, 
          COHORT_MIN_TERM, promise_p, 
         CUM_GPA_OVERALL, CUM_EARNED_OVERALL, PELL_ELIG,
         math, engl, inst, fed_career, pri_career, cte_career, 
         rem_career, fails_career, withs_career, ret1720, ret1740,
         avg_cls_sz, zip, mean_crd_att, first_sem, term_gpa_201640)

ff_gpa_2016 <- full_data_awards %>%
  filter(is.na(award_flag) == T) %>%
  filter(TERM_CODE == 201640) %>%
  filter(is.na(CUM_GPA_OVERALL) == F & first_sem == 1) %>%
  filter(PELL_ELIG == 1) %>%
  dplyr::select(PIDM, TERM_CODE, term_age, first_gen, eth, male, 
          COHORT_MIN_TERM, promise_p, 
         CUM_GPA_OVERALL, CUM_EARNED_OVERALL, PELL_ELIG,
         math, engl, inst, fed_career, pri_career, cte_career, 
         rem_career, fails_career, withs_career, ret1720, ret1740,
         avg_cls_sz, zip, mean_crd_att, first_sem, term_gpa_201640)
```
- Just filtering down full_data_awards. 

-NA problem with ethnicity variable
```{r, echo=T, message=F}
# fixing an NA problem with the sub-groups
cs_gpa_2016$eth[is.na(cs_gpa_2016$eth)] <- "oth_eth"
ff_gpa_2016$eth[is.na(ff_gpa_2016$eth)] <- "oth_eth"
ff_nogpa_2016$eth[is.na(ff_nogpa_2016$eth)] <- "oth_eth"
```

# three groups
Propensity scores will be estimated for three of four subgroups
- continuing students in 201640 with a value for CUM_GPA_OVERALL: 3889 students cs_gpa_2016
- first time full time students in 201640 with a value for CUM_GPA_OVERALL: 440 students ff_gpa_2016
- first time full time students in 201640 without a value for CUM_GPA_OVERALL: 1602 students ff_nogpa_2016

### cs_gpa_2016
These students will have the most robust matches since there is information on their academic ability/performance at SLCC or another higher ed institutions prior to 201640. It is also believed however, these students are likely retainers since they are entering at least their second semester of college. 
- 17 raw propensity score variables. 

### ff_gpa_2016
These students have a COHORT_MIN_TERM == 201640. Technically  these students are in their first semester at SLCC but have a CUM_GPA_OVERALL at the begining of 201640. This means they have some academic history (probably as concurrent enrollment) at SLCC or another institution of higher ed. The concurrent enrollment flag in banner seems to have problems with it currently (as per Abby 9/25).
- 17 raw propensity score variables. same as cs_gpa_2016 since these students have records at the higher ed level. 

### ff_nogpa_2016
These students have a COHORT_MIN_TERM == 201640. Technically these students are in their first semester and they have no recorded CUM_GPA_OVERALL, so no gpa prior to 201640. 
- 7 raw propensity score variables. eliminated anything relating to prior higher ed expereince. 
- These students are essentially being matched on non-academic variables. fed_career and pri_career are left in since some of these students seem to have prior academic loans. They either were for education that would not count for SLCC or the student didn't bother to transfer credits. These are left in since there might be "non-FTFT" students in the FTFT student group, if this distinction is significant then leaving in these variables will allow for that impact to be represented somewhere.

## cs_gpa ps
```{r, echo=T, results=F, warning=F, message=F}
library(caret)
# using gbm since it is easy to use
# gbm for cs_gpa_2016
set.seed(42)
cs_gpa_2016_gbm <- train(as.factor(promise_p) ~ ., 
               data = cs_gpa_2016[,!(names(cs_gpa_2016) %in% c('PIDM', 'TERM_CODE', 'COHORT_MIN_TERM',
                                                               'PELL_ELIG', 'ret1720', 'ret1740', 'zip', 'first_sem', 'term_gpa_201640'))], 
               method = "gbm", 
               trControl = trainControl(method = "cv", 
                                        number = 10, 
                                        verboseIter = TRUE))

cs_gpa_pred <- predict(cs_gpa_2016_gbm, cs_gpa_2016, type = "prob")
ps_cs_gpa_gbm <- cbind(cs_gpa_pred$`1`)
ps_cs_gpa <- data.frame(cs_gpa_2016, ps_cs_gpa_gbm)

ps_cs_gpa %>% ggplot() + 
  geom_histogram(aes(ps_cs_gpa_gbm, col = as.factor(promise_p)))

cs_gpa_2016_gbm_sum <- summary(cs_gpa_2016_gbm)
cs_gpa_2016_gbm_sum
```

```{r, echo=T, warning=F, message=F}
cs_gpa_2016_gbm_sum
```

## ff_gpa ps
```{r, echo=T, results=F, warning=F, message=F}
# gbm for ff_gpa
set.seed(42)
ff_gpa_2016_gbm <- train(as.factor(promise_p) ~ ., 
               data = ff_gpa_2016[,!(names(ff_gpa_2016) %in% c('PIDM', 'TERM_CODE', 'COHORT_MIN_TERM',
                                                               'PELL_ELIG', 'ret1720', 'ret1740', 'zip', 'first_sem',
                                                               'term_gpa_201640'))], 
               method = "gbm", 
               trControl = trainControl(method = "cv", 
                                        number = 10, 
                                        verboseIter = TRUE))

ff_gpa_pred <- predict(ff_gpa_2016_gbm, ff_gpa_2016, type = "prob")
ps_ff_gpa_gbm <- cbind(ff_gpa_pred$`1`)
ps_ff_gpa <- data.frame(ff_gpa_2016, ps_ff_gpa_gbm)

ps_ff_gpa %>% ggplot() + 
  geom_histogram(aes(ps_ff_gpa_gbm, col = as.factor(promise_p)))

ff_gpa_2016_gbm_sum <- summary(ff_gpa_2016_gbm)
ff_gpa_2016_gbm_sum
```

```{r, echo=T, warning=F, message=F}
ff_gpa_2016_gbm_sum
```

## ff_nogpa ps
```{r, echo=T, results=F, warning=F, message=F}
set.seed(42)
ff_nogpa_2016_gbm <- train(as.factor(promise_p) ~ ., 
               data = ff_nogpa_2016[,!(names(ff_nogpa_2016) %in% c('PIDM', 'TERM_CODE', 'COHORT_MIN_TERM',
                                                               'PELL_ELIG', 'ret1720', 'ret1740', 'zip', 'first_sem',
                                                               'CUM_GPA_OVERALL', 'CUM_EARNED_OVERALL',
                                                               'math', 'engl', 'inst', 'cte_career', 'rem_career',
                                                               'fails_career', 'withs_career', 'mean_crd_att', 'avg_cls_sz',
                                                               'term_gpa_201640'))], 
               method = "gbm", 
               trControl = trainControl(method = "cv", 
                                        number = 10, 
                                        verboseIter = TRUE))

ff_nogpa_pred <- predict(ff_nogpa_2016_gbm, ff_nogpa_2016, type = "prob")
ps_ff_nogpa_gbm <- cbind(ff_nogpa_pred$`1`)
ps_ff_nogpa <- data.frame(ff_nogpa_2016, ps_ff_nogpa_gbm)

ps_ff_nogpa %>% ggplot() + 
  geom_histogram(aes(ps_ff_nogpa_gbm, col = as.factor(promise_p)))

ff_nogpa_2016_gbm_sum <- summary(ff_nogpa_2016_gbm)
```

```{r, echo=T, warning=F, message=F}
ff_nogpa_2016_gbm_sum
```


# modeling promise inclusion first.
As per Webb. Model retention first based. done. will have to do retention model on my own time. 

## Jessie's idea
Generate propensity scores for all exact match on minimum cohort year. match on zip. done/interpreted. done/not interpreted seemed similar.
- how to flag students who have tested out of Math courses? not done. these student's will count as NA for the math/engl factor.
- hos to flag students who haven't taken either math or engl? done. Used highest math/engl course as factors in the gbm

## check
- credits failed, still check the new fails_careers
- credits with
-  blah <- full_data_awards %>% filter(PELL_ELIG == 1 & FAFSA == 0) not good


## make
- highest math course number. done
- highest engl course number. done
- fed loan career. done
- private loan career. done
- former concurrent from student_list when you get back. doneish. used three groups instead. CS, FF with gpa (former concurrent/transfer), FF without GPA. 

## consideration
- run first semesters seperately. done ran three seperate analyses. continuing studnets with gpa, first-time students with gpa and first time students without gpa. 
- first time students with gpa might be mostly former concurrent.
- not all CS had gpa. like 44, they were dropped. 
# results
## matching CS_GPA ret1720
```{r, echo=T, results=F, warning=F, message=F}
# matching
library(Matching)
# cs_gpa_2016 matching using ps_cs_gpa

Y <- ps_cs_gpa$ret1720
Tr <- ps_cs_gpa$promise_p
X <- ps_cs_gpa$ps_cs_gpa_gbm
by <- as.factor(ps_cs_gpa$COHORT_MIN_TERM)
match_cs_gpa <- Matchby(Y = Y, Tr = Tr, X = X, by = by, 
                        estimand = "ATT", M = 1, AI = TRUE,
                        caliper = .25)


rm(Y, Tr, X, by)
# MatchBalance
mb_match_cs_gpa <- MatchBalance(ps_cs_gpa$promise_p ~ 
                                  ps_cs_gpa$term_age + ps_cs_gpa$male + ps_cs_gpa$first_gen + ps_cs_gpa$eth +
                                  ps_cs_gpa$CUM_GPA_OVERALL + ps_cs_gpa$CUM_EARNED_OVERALL + 
                                  ps_cs_gpa$inst + ps_cs_gpa$rem_career + ps_cs_gpa$cte_career + 
                                  ps_cs_gpa$fed_career + ps_cs_gpa$pri_career + ps_cs_gpa$math +
                                  ps_cs_gpa$engl + ps_cs_gpa$avg_cls_sz + ps_cs_gpa$fails_career + 
                                  ps_cs_gpa$withs_career + ps_cs_gpa$mean_crd_att + ps_cs_gpa$term_gpa_201640, 
                                match.out = match_cs_gpa, ks = T, nboots = 500)

mbps_match_cs_gpa <- MatchBalance(ps_cs_gpa$promise_p ~ ps_cs_gpa$ps_cs_gpa_gbm, 
                                  match.out = match_cs_gpa, ks = T, nboots = 500)

```

```{r, echo=T, warning=F, message=F}
print(summary(match_cs_gpa))

```
No significant impact on retention for Spring 2017.

#### cs_gpa match plots
```{r, echo=T, warning=F, message=F}
# mean_crd_att
ggplot() + geom_histogram(aes(ps_cs_gpa$mean_crd_att[match_cs_gpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_cs_gpa$mean_crd_att[match_cs_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated mean_crd_att")

# term_age
ggplot() + geom_histogram(aes(ps_cs_gpa$term_age[match_cs_gpa$index.treated]), col = "red", alpha = .0) + 
  geom_histogram(aes(ps_cs_gpa$term_age[match_cs_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated term age")

# fed_career
ggplot() + geom_histogram(aes(ps_cs_gpa$fed_career[match_cs_gpa$index.treated]), col = "red", alpha = .0) + 
  geom_histogram(aes(ps_cs_gpa$fed_career[match_cs_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated fed loans career")

# cum_gpa_overall
ggplot() + geom_histogram(aes(ps_cs_gpa$CUM_GPA_OVERALL[match_cs_gpa$index.treated]), col = "red", alpha = .0) + 
  geom_histogram(aes(ps_cs_gpa$CUM_GPA_OVERALL[match_cs_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated cummulative gpa")

# cum_earned_overall
ggplot() + geom_histogram(aes(ps_cs_gpa$CUM_EARNED_OVERALL[match_cs_gpa$index.treated]), col = "red", alpha = .0) + 
  geom_histogram(aes(ps_cs_gpa$CUM_EARNED_OVERALL[match_cs_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated credits earned")

# avg_cl_sz
ggplot() + geom_histogram(aes(ps_cs_gpa$avg_cls_sz[match_cs_gpa$index.treated]), col = "red", alpha = .0) + 
  geom_histogram(aes(ps_cs_gpa$avg[match_cs_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated average class size")

# rem career
ggplot() + geom_histogram(aes(ps_cs_gpa$rem_career[match_cs_gpa$index.treated]), col = "red", alpha = .0) + 
  geom_histogram(aes(ps_cs_gpa$rem_career[match_cs_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated mean_crd_att")

# inst
ggplot() + geom_histogram(aes(ps_cs_gpa$inst[match_cs_gpa$index.treated]), col = "red", alpha = .0) + 
  geom_histogram(aes(ps_cs_gpa$inst[match_cs_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated instruction type")

# male
ggplot() + geom_histogram(aes(ps_cs_gpa$male[match_cs_gpa$index.treated]), col = "red", alpha = .0) + 
  geom_histogram(aes(ps_cs_gpa$male[match_cs_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated male")

# term_gpa_201640
ggplot() + geom_histogram(aes(ps_cs_gpa$term_gpa_201640[match_cs_gpa$index.treated]), col = "red", alpha = .0) + 
  geom_histogram(aes(ps_cs_gpa$term_gpa_201640[match_cs_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated term gpa 201640 score")

# ps score
ggplot() + geom_histogram(aes(ps_cs_gpa$ps_cs_gpa_gbm[match_cs_gpa$index.treated]), col = "red", alpha = .0) + 
  geom_histogram(aes(ps_cs_gpa$ps_cs_gpa_gbm[match_cs_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated ps score")

# ret1720
ggplot() + geom_histogram(aes(ps_cs_gpa$ret1720[match_cs_gpa$index.treated]), col = "red", alpha = .0) + 
  geom_histogram(aes(ps_cs_gpa$ret1720[match_cs_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated retention")
```

## matching CS_GPA term_gpa_201720*
```{r, echo=T, results=F, warning=F, message=F}
# term_gpa_201720 outcome variable
# cs_gpa_2016 matching using ps_cs_gpa

Y_gpa <- ps_cs_gpa$term_gpa_201640
Tr <- ps_cs_gpa$promise_p
X <- ps_cs_gpa$ps_cs_gpa_gbm
by <- as.factor(ps_cs_gpa$COHORT_MIN_TERM)
match_cs_gpa_term <- Matchby(Y = Y_gpa, Tr = Tr, X = X, by = by, 
                        estimand = "ATT", M = 1, AI = TRUE,
                        caliper = .25)


rm(Y_gpa, Tr, X, by)
# MatchBalance
mb_match_cs_gpa_term <- MatchBalance(ps_cs_gpa$promise_p ~ 
                                  ps_cs_gpa$term_age + ps_cs_gpa$male + ps_cs_gpa$first_gen + ps_cs_gpa$eth +
                                  ps_cs_gpa$CUM_GPA_OVERALL + ps_cs_gpa$CUM_EARNED_OVERALL + 
                                  ps_cs_gpa$inst + ps_cs_gpa$rem_career + ps_cs_gpa$cte_career + 
                                  ps_cs_gpa$fed_career + ps_cs_gpa$pri_career + ps_cs_gpa$math +
                                  ps_cs_gpa$engl + ps_cs_gpa$avg_cls_sz + ps_cs_gpa$fails_career + 
                                  ps_cs_gpa$withs_career + ps_cs_gpa$mean_crd_att, 
                                match.out = match_cs_gpa, ks = T, nboots = 500)
```

```{r, echo=T, warning=F, message=F}
print(summary(match_cs_gpa_term))

```
Seems to be a small positive impact on grades. I think this isn't causal but correlation. Strength of schedule wasn't controlled for etc.

## matching FF_GPA ret1720*
```{r, echo=T, results=F, warning=F, message=F}
Y <- ps_ff_gpa$ret1720
Tr <- ps_ff_gpa$promise_p
X <- ps_ff_gpa$ps_ff_gpa_gbm
by <- as.factor(ps_ff_gpa$COHORT_MIN_TERM)
match_ff_gpa <- Matchby(Y = Y, Tr = Tr, X = X, by = by, 
                        estimand = "ATT", M = 1, AI = TRUE,
                        caliper = .25)


rm(Y, Tr, X, by)
# not surprising that they all match on min_cohort_term since they are all in their first term
# mb_match_ff_gpa <- MatchBalance(ps_ff_gpa$promise_p ~ 
#                                   ps_ff_gpa$term_age + ps_ff_gpa$male + 
#                                   ps_ff_gpa$CUM_GPA_OVERALL + ps_ff_gpa$CUM_EARNED_OVERALL + 
#                                   ps_ff_gpa$inst + ps_ff_gpa$rem_career + ps_ff_gpa$cte_career + 
#                                   ps_ff_gpa$fed_career + ps_ff_gpa$pri_career + ps_ff_gpa$math +
#                                   ps_ff_gpa$engl + ps_ff_gpa$avg_cls_sz + ps_ff_gpa$term_gpa_201640, 
#                                 match.out = match_ff_gpa, ks = T, nboots = 500)
```

```{r, echo=T, warning=F, message=F}
print(summary(match_ff_gpa))
```
No significant impact on retention for Spring 2017. Now seems to have an effect on retention????
- Check that the ps scores aren't moving around.

#### ff_gpa match plots
```{r, echo=T, warning=F, message=F}
# mean_crd_att
ggplot() + geom_histogram(aes(ps_ff_gpa$mean_crd_att[match_ff_gpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_gpa$mean_crd_att[match_ff_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated mean_crd_att")

# fed career
ggplot() + geom_histogram(aes(ps_ff_gpa$fed_career[match_ff_gpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_gpa$fed_career[match_ff_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated federal loan career")

# term age
ggplot() + geom_histogram(aes(ps_ff_gpa$term_age[match_ff_gpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_gpa$term_age[match_ff_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated term age")

# cum-earned-overall
ggplot() + geom_histogram(aes(ps_ff_gpa$CUM_EARNED_OVERALL[match_ff_gpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_gpa$CUM_EARNED_OVERALL[match_ff_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated cumulative earned credits")

# cum_gpa_overall
ggplot() + geom_histogram(aes(ps_ff_gpa$CUM_GPA_OVERALL[match_ff_gpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_gpa$CUM_GPA_OVERALL[match_ff_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated cumulative gpa")

# rem_career
ggplot() + geom_histogram(aes(ps_ff_gpa$rem_career[match_ff_gpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_gpa$rem_career[match_ff_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated remedial career")

# cte_career
ggplot() + geom_histogram(aes(ps_ff_gpa$cte_career[match_ff_gpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_gpa$cte_career[match_ff_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated cte career")

# fails_career
ggplot() + geom_histogram(aes(ps_ff_gpa$fails_career[match_ff_gpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_gpa$fails_career[match_ff_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated career fails")

# inst
ggplot() + geom_histogram(aes(ps_ff_gpa$inst[match_ff_gpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_gpa$inst[match_ff_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated instruction type")

# avg_cls_size
ggplot() + geom_histogram(aes(ps_ff_gpa$avg_cls_sz[match_ff_gpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_gpa$avg_cls_sz[match_ff_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated average class size")

# term_gpa_201740
ggplot() + geom_histogram(aes(ps_ff_gpa$term_gpa_201640[match_ff_gpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_gpa$term_gpa_201640[match_ff_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated term gpa 201640")

# ps 
ggplot() + geom_histogram(aes(ps_ff_gpa$ps_ff_gpa_gbm[match_ff_gpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_gpa$ps_ff_gpa_gbm[match_ff_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated ps")

# ret1720
ggplot() + geom_histogram(aes(ps_ff_gpa$ret1720[match_ff_gpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_gpa$ret1720[match_ff_gpa$index.control]), alpha = 0.3) + 
  xlab("red = treated retention")

```

## matching ff_gpa term_gpa_201720
```{r, echo=T,  warning=F, message=F}
# since they are already matched on min_cohort matching on zip
Y_gpa <- ps_ff_gpa$term_gpa_201640
Tr <- ps_ff_gpa$promise_p
X <- ps_ff_gpa$ps_ff_gpa_gbm
by <- as.factor(ps_ff_gpa$COHORT_MIN_TERM)
match_ff_gpa_term <- Matchby(Y = Y_gpa, Tr = Tr, X = X, by = by, 
                        estimand = "ATT", M = 1, AI = TRUE,
                        caliper = .25)

rm(Y_gpa, Tr, X, by)
# not surprising that they all match on min_cohort_term since they are all in their first term
# mb_match_ff_gpa_term <- MatchBalance(ps_ff_gpa$promise_p ~ 
                                #   ps_ff_gpa$term_age + ps_ff_gpa$male + 
                                #   ps_ff_gpa$CUM_GPA_OVERALL + ps_ff_gpa$CUM_EARNED_OVERALL + 
                                #   ps_ff_gpa$inst + ps_ff_gpa$rem_career + ps_ff_gpa$cte_career + 
                                #   ps_ff_gpa$fed_career + ps_ff_gpa$pri_career + ps_ff_gpa$math +
                                #   ps_ff_gpa$engl + ps_ff_gpa$avg_cls_sz, 
                                # match.out = match_ff_gpa, ks = T, nboots = 500)

print(summary(match_ff_gpa_term))

```
No significant impact on grades.

## matching ff_nogpa ret1720
```{r, echo=T, warning=F, message=F}
# since they are already matched on cohort_min_term matching on zip
Y <- ps_ff_nogpa$ret1720
Tr <- ps_ff_nogpa$promise_p
X <- ps_ff_nogpa$ps_ff_nogpa_gbm
by <- as.factor(ps_ff_nogpa$zip)
match_ff_nogpa <- Matchby(Y = Y, Tr = Tr, X = X, by = by, 
                        estimand = "ATT", M = 1, AI = TRUE,
                        caliper = .25)

rm(Y, Tr, X, by)

print(summary(match_ff_nogpa))

```
No significant impact on retention for Spring 2017.

#### ff-nogpa match plots
```{r, echo=T, warning=F, message=F}
# fed_career
ggplot() + geom_histogram(aes(ps_ff_nogpa$fed_career[match_ff_nogpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_nogpa$fed_career[match_ff_nogpa$index.control]), alpha = 0.3) + 
  xlab("red = treated mean_crd_att")

# term age
ggplot() + geom_histogram(aes(ps_ff_nogpa$term_age[match_ff_nogpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_nogpa$term_age[match_ff_nogpa$index.control]), alpha = 0.3) + 
  xlab("red = treated mean_crd_att")

# term gpa 201640
ggplot() + geom_histogram(aes(ps_ff_nogpa$term_gpa_201640[match_ff_nogpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_nogpa$term_gpa_201640[match_ff_nogpa$index.control]), alpha = 0.3) + 
  xlab("red = treated mean_crd_att")

# ps 
ggplot() + geom_histogram(aes(ps_ff_nogpa$ps_ff_nogpa_gbm[match_ff_nogpa$index.treated]), col = "red",  alpha = .0) + 
  geom_histogram(aes(ps_ff_nogpa$ps_ff_nogpa_gbm[match_ff_nogpa$index.control]), alpha = 0.3) + 
  xlab("red = treated mean_crd_att")

```

## ff_nogpa term_gpa_201720
```{r, echo=T, warning=F, message=F}
Y_term <- ps_ff_nogpa$term_gpa_201640
Tr <- ps_ff_nogpa$promise_p
X <- ps_ff_nogpa$ps_ff_nogpa_gbm
by <- as.factor(ps_ff_nogpa$COHORT_MIN_TERM)
match_ff_nogpa_term <- Matchby(Y = Y_term, Tr = Tr, X = X, by = by, 
                        estimand = "ATT", M = 1, AI = TRUE,
                        caliper = .25)

print(summary(match_ff_nogpa_term))
rm(Y_gpa, Tr, X, by)
# not surprising that they all match on min_cohort_term since they are all in their first term
```
No significant impact on grades.

### summarising output
```{r, echo=FALSE}
# mb_match_cs_gpa$BeforeMatching[[2]]["mean.Co"]

pre_post_balance <- list()

function(df, phase, x, group){
  pre_post_balance <- df$phase[[x]][group]
}

```

# APPENDIX

Misc. code that was used along the way.

```{r, echo=FALSE, eval=FALSE}
library(caret)
# using ps_1516 (both 1540 & 1620) 
# 160 promise students in the data set
ps_1516 <- ps_1516[, !names(ps_1516) %in% c("TERM_201540", "TERM_201620", "TERM_CODE", "first_sem_201620")] # there was no variation in first_sem_201620

# library(twang)
# ps_model_twang <- ps(promise_p ~ ., data = ps_1516)

# Generalized boosted regression models
library(gbm)
ps_model_gbm <- gbm(promise_p ~ . - PIDM, 
                    data = ps_1516, 
                    n.trees = 10000)
n <- gbm.perf(ps_model_gbm) # 5639
plot(ps_model_gbm, i.var = 1)
pretty.gbm.tree(ps_model_gbm)
print(ps_model_gbm)

ps_gbm <- predict(ps_model_gbm, 
                  n.trees = 5639, 
                  ps_1516, 
                  type = "response")

ps_gbm
summary(ps_gbm)

blah <- cbind(ps_gbm)

ps_1516_gbm <- data.frame(ps_1516, blah)
rm(blah)

# Random forest
library(ranger)
ps_model_ranger <- ranger(as.factor(promise_p) ~ . -PIDM, 
                          num.trees = 500, 
                          data = ps_1516, 
                          write.forest = TRUE, 
                          probability = TRUE)

print(ps_model_ranger)

ps_ranger <- predict(ps_model_ranger, ps_1516, 
                     type = "response", 
                     num.trees = 250) # way! over fitted. Perfectly predicts essentially 

blah <- cbind(ps_ranger$predictions)
ps_1516_ranger <- data.frame(ps_1516, blah[,2])
rm(blah)

# logistic regression: scale all variables first? interact variables?
ps_model_glm <- glm(promise_p ~ . - PIDM, 
                    data = ps_1516, 
                    family = "binomial")
summary(ps_model_glm)

X <- 
ps_glm <- predict(ps_model_glm, ps_1516, type = "response")

blah <- cbind(ps_glm)
ps_1516_glm <- data.frame(ps_1516, blah)
rm(blah)

# gbm
set.seed(42)
model_gbm <- train(as.factor(promise_p) ~ . -PIDM, 
               data = ps_1516, 
               method = "gbm", 
               trControl = trainControl(method = "cv", 
                                        number = 10, 
                                        verboseIter = TRUE))

ps_caret <- predict(model_gbm, ps_1516, type = "prob")
ps_gbm <- cbind(ps_caret$`1`)
ps_caret_gbm <- data.frame(ps_1516, ps_gbm)
rm(ps_gbm)

# logit
sed.seed(42)
model_glm <- train(as.factor(promise_p) ~ . -PIDM, 
               data = ps_1516, 
               method = "glm", 
               trControl = trainControl(method = "cv", 
                                        number = 10, 
                                        verboseIter = TRUE))

ps_c

# ranger
set.seed(42)
model_ranger <- train(as.factor(promise_p) ~ . -PIDM, 
               data = ps_1516, 
               method = "ranger", 
               trControl = trainControl(method = "cv", 
                                        number = 10, 
                                        verboseIter = TRUE))

ps_caret <- predict(model_ranger, ps_1516, type = "prob")
ps_ranger <- cbind(ps_caret$`1`)
ps_caret_ranger <- data.frame(ps_1516, ps_ranger)
rm(ps_ranger)
```

```{r, echo=FALSE, eval=FALSE}
# more plots
ps_1516_gbm %>%
  ggplot() + 
  geom_histogram(aes(ps_gbm)) +
  facet_wrap(~as.factor(promise_p), scales = "free")
  
ps_1516_ranger %>%
  ggplot() + 
  geom_histogram(aes(blah...2.)) +
  facet_wrap(~as.factor(promise_p), scales = "free")

ps_1516_glm %>%
  ggplot() + 
  geom_histogram(aes(ps_glm)) +
  facet_wrap(~as.factor(promise_p), scales = "free")

# caret plots
ps_caret_gbm %>%
  ggplot() + 
  geom_histogram(aes(ps_gbm)) + 
  facet_wrap(~as.factor(promise_p), scales = "free")

ps_caret_gbm %>%
  ggplot() + 
  geom_density(aes(ps_gbm, col = as.factor(promise_p))) +
  xlab("propensity scores from gbm") + 
  ylab("") 
```

```{r, echo=FALSE, eval=FALSE}
# select students enrolled in 201640 who did not graduate in 201640
full_data_awards$PIDM <- as.character(full_data_awards$PIDM)
pidm_201640 <- full_data_awards %>% 
  filter(TERM_CODE == 201640) %>% 
  filter(is.na(award_flag) == T) %>% 
  filter(PELL_ELIG == 1) %>% 
  dplyr::select(PIDM, TERM_CODE) # 5975... 5974 unique

elig_2016_set <- full_data_awards %>% 
  dplyr::semi_join(pidm_201640, by = "PIDM") # student/term 

fixed_2016 <- elig_2016_set %>% dplyr::filter(TERM_CODE == 201640) %>% 
  dplyr::select(PIDM, 
                TERM_CODE, 
                term_age, 
                first_gen, 
                eth, 
                male, 
                crds_fails, 
                crds_with, 
                COHORT_MIN_TERM, 
                promise_p, 
                CUM_GPA_OVERALL, 
                CUM_EARNED_OVERALL, 
                zip, 
                S_ENTRY_ACTION, 
                max_time, 
                min_time,
                max_math,
                max_engl,
                rem_courses, 
                cte_courses, 
                HIGH_SCHOOL_CODE)

#

# join based on fixed_2016 PIDM
vari_2016 <- elig_2016_set %>%
  filter(TERM_CODE != 201640 | TERM_CODE != 201720 | TERM_CODE != 201730 | TERM_CODE != 201740) %>% 
  group_by(PIDM) %>%
  summarise(avg_cls_sz_car = mean(avg_cls_sz), 
            instrction_type_car = mean(instrction_type), 
            tot_fed = sum(FED_LOAN), 
            tot_pri = sum(PRIVATE_LOAN), 
            crds_fails_car = sum(crds_fails),
            crds_with_car = sum(crds_with))

max_time = max(COURSE_BEGIN_TIME), 
            min_time = min(COURSE_BEGIN_TIME), 
            avg_cls_sz = mean(TOTAL_ENROLLMENT),
            crds_fails = sum(CREDITS_FAILED),
            crds_with = sum(CREDITS_WITHDRAWN),
            engl1010 = sum(ENGL1010),
            math1010 = sum(MATH1010),
            instrction_type = mean(instrc_type_dum)

# elig_2016_set %>% group_by(COHORT_MIN_TERM) %>% tally() %>% View
# elig_2016_set %>% group_by(COHORT_MIN_TERM) %>% filter(promise_p == 1) %>% tally() %>% View

# both 2015 to 2016

# just 2016

# just 2015

# all other cs

# all first semester

fixed_cov <- full_data_awards %>% 
  filter(TERM_CODE == 201640) %>%
  dplyr::select( eth, male, COHORT_MIN_TERM,
                zip, HIGH_SCHOOL_CODE, promise_p,
                first_gen, CUM_GPA_OVERALL, CUM_EARNED_OVERALL)

ps_set <- 
```

```{r, echo = FALSE, eval=FALSE}
# joining pre 201640 matching covariates
# pre_201640 <- full_join(pre_201540, pre_201620,  by = "PIDM")
# 
# ps_data <- elig_2016_set %>% inner_join(pre_201640, by = "PIDM")
# 
# ps_data <- ps_data %>% filter(is.na(CUM_GPA_OVERALL) == F)
# not necessary with the new matching procejure

```

```{r, echo=FALSE, eval=FALSE}
# two seperate matches
# 201620 
# ps_data_201620 <- elig_2016_set %>% inner_join(pre_201620, by = "PIDM") %>% filter(is.na(CUM_GPA_OVERALL) == FALSE)
# # dim(ps_data_201620) # 9671 by 26
# # NAs
# ps_data_201620$crds_fails[is.na(ps_data_201620$crds_fails) == T] <- 0
# ps_data_201620$crds_with[is.na(ps_data_201620$crds_with) == T] <- 0
# ps_data_201620$cte_courses_201620[is.na(ps_data_201620$cte_courses_201620) == T] <- 0
# ps_data_201620$rem_courses_201620[is.na(ps_data_201620$rem_courses_201620) == T] <- 0
# ps_data_201620$PELL_ELIG <- as.double(ps_data_201620$PELL_ELIG)
# ps_data_201620$PELL_ELIG[is.na(ps_data_201620$PELL_ELIG) == T] <- 0
# ps_data_201620$eth <- as.factor(ps_data_201620$eth)
# ps_data_201620$eth[is.na(ps_data_201620$eth) == T] <- "oth_eth"
# ps_data_201620$first_gen <- as.factor(ps_data_201620$first_gen)
# 
# # 201540
# ps_data_201540 <- elig_2016_set %>% inner_join(pre_201540, by = "PIDM") %>% filter(is.na(CUM_GPA_OVERALL) == FALSE)
# # dim(ps_data_201540) # 8548 by 26
# #NAs
# ps_data_201540$crds_fails[is.na(ps_data_201540$crds_fails) == T] <- 0
# ps_data_201540$crds_with[is.na(ps_data_201540$crds_with) == T] <- 0
# ps_data_201540$cte_courses_201540[is.na(ps_data_201540$cte_courses_201540) == T] <- 0
# ps_data_201540$rem_courses_201540[is.na(ps_data_201540$rem_courses_201540) == T] <- 0
# ps_data_201540$PELL_ELIG <- as.double(ps_data_201540$PELL_ELIG)
# ps_data_201540$PELL_ELIG[is.na(ps_data_201540$PELL_ELIG) == T] <- 0
# ps_data_201540$eth <- as.factor(ps_data_201540$eth)
# ps_data_201540$eth[is.na(ps_data_201540$eth) == T] <- "oth_eth"
# ps_data_201540$first_gen <- as.factor(ps_data_201540$first_gen)
# 
# # both 201540 & 201620
# 
# int_join <- pre_201540 %>% inner_join(pre_201620, by = "PIDM")
# ps_1516 <- elig_2016_set %>% inner_join(int_join, by = "PIDM") %>% filter(is.na(CUM_GPA_OVERALL) == FALSE)
# rm(int_join)
# # dim(ps_1516) # 7118 by 38
# 
# ps_1516$crds_fails[is.na(ps_1516$crds_fails) == T] <- 0
# ps_1516$crds_with[is.na(ps_1516$crds_with) == T] <- 0
# ps_1516$cte_courses_201540[is.na(ps_1516$cte_courses_201540) == T] <- 0
# ps_1516$rem_courses_201540[is.na(ps_1516$rem_courses_201540) == T] <- 0
# ps_1516$cte_courses_201620[is.na(ps_1516$cte_courses_201620) == T] <- 0
# ps_1516$rem_courses_201620[is.na(ps_1516$rem_courses_201620) == T] <- 0
# ps_1516$PELL_ELIG <- as.double(ps_1516$PELL_ELIG)
# ps_1516$PELL_ELIG[is.na(ps_1516$PELL_ELIG) == T] <- 0
# ps_1516$eth <- as.factor(ps_1516$eth)
# ps_1516$eth[is.na(ps_1516$eth) == T] <- "oth_eth"
# ps_1516$first_gen <- as.factor(ps_1516$first_gen)


# no NAs in the new matching analysis
```

```{r, echo=FALSE, eval=FALSE}
# trying matching on zip.... doesn't help
Y <- ps_cs_gpa$ret1720
Tr <- ps_cs_gpa$promise_p
X <- ps_cs_gpa$ps_cs_gpa_gbm
by <- as.factor(ps_cs_gpa$zip)
match_cs_gpa <- Matchby(Y = Y, Tr = Tr, X = X, by = by, 
                        estimand = "ATT", M = 1, AI = TRUE,
                        caliper = .25)
summary(match_cs_gpa)
```

```{r, echo=FALSE, eval=FALSE}
# trying matching on zip.... doesn't help
Y <- ps_ff_gpa$ret1720
Tr <- ps_ff_gpa$promise_p
X <- ps_ff_gpa$ps_ff_gpa_gbm
by <- as.factor(ps_ff_gpa$zip)
match_ff_gpa <- Matchby(Y = Y, Tr = Tr, X = X, by = by, 
                        estimand = "ATT", M = 1, AI = TRUE,
                        caliper = .25)

summary(match_ff_gpa)
```

```{r, echo=FALSE, eval=FALSE}
# trying matching on zip.... doesn't help
Y <- ps_ff_nogpa$ret1720
Tr <- ps_ff_nogpa$promise_p
X <- ps_ff_nogpa$ps_ff_nogpa_gbm
by <- as.factor(ps_ff_nogpa$zip)
match_ff_nogpa <- Matchby(Y = Y, Tr = Tr, X = X, by = by, 
                        estimand = "ATT", M = 1, AI = TRUE,
                        caliper = .25)

summary(match_ff_nogpa)
```
```{r, eval=FALSE, echo=FALSE}
# data pull for transfer data from clearning house.
transfers <-  full_data_awards %>%
  filter(is.na(award_flag) == T) %>%
  filter(TERM_CODE == 201640) %>%
  filter(PELL_ELIG == 1) %>%
  dplyr::select(PIDM)

TRANSFERS <- transfers %>% left_join(ret_data) %>% dplyr::distinct(PIDM, FIRST_NAME, MIDDLE_NAME, LAST_NAME, BIRTH_DATE)
write_csv(TRANSFERS, "promise_20170920.csv")
```


```{r, echo=FALSE, eval=FALSE}
# concurent students data request
concurrent <- ff_gpa_2016 %>% dplyr::select(PIDM)
write_csv(concurrent, "promise_retention_20170929.csv")
```

```{r, eval=FALSE, echo=FALSE}

# ps cs_gpa
cs_ps_plot <- ggplot() + geom_histogram(aes(ps_cs_gpa$ps_cs_gpa_gbm[match_cs_gpa$index.treated]), color = "#00abe1", alpha = .00) +
  geom_histogram(aes(ps_cs_gpa$ps_cs_gpa_gbm[match_cs_gpa$index.control]), fill = "#ffcd00", alpha = 0.5) + 
  xlab("Propensity score for promise inclusion") +
  labs(title = "Propensity score comparison for continuing students Fall 2016") +
  guides(color = "Promise students")
  
png(filename = "cs_gpa.png")
cs_ps_plot
dev.off()

# ps ff_nogpa
ff_nops_plot <- ggplot() + geom_histogram(aes(ps_ff_nogpa$ps_ff_nogpa_gbm[match_ff_nogpa$index.treated]), col = "#00abe1",  alpha = .0) + 
  geom_histogram(aes(ps_ff_nogpa$ps_ff_nogpa_gbm[match_ff_nogpa$index.control]), fill = "#ffcd00", alpha = 0.5) + 
    xlab("Propensity score for promise inclusion") +
  labs(title = "Propensity score comparison for first time Fall 2016 students with no records") +
  guides(color = "Promise students")

png(filename = "ff_nops_plot.png")
ff_nops_plot
dev.off()

# ps ff_gpa
ff_ps_plot <- ggplot() + geom_histogram(aes(ps_ff_gpa$ps_ff_gpa_gbm[match_ff_gpa$index.treated]), col = "#00abe1",  alpha = .0) + 
  geom_histogram(aes(ps_ff_gpa$ps_ff_gpa_gbm[match_ff_gpa$index.control]), fill = "#ffcd00", alpha = 0.5) + 
  xlab("Propensity score for promise inclusion") +
  labs(title = "Propensity score comparison for first time Fall 2016 students with records") +
  guides(color = "Promise students")

png(filename = "ff_ps_plot.png")
ff_ps_plot
dev.off()

```

